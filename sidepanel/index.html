<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADO to PA Copypaster</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

  <!--
    Script loading order matters for Alpine.js store registration:

      1. app.js (synchronous, no defer) â€” registers the 'alpine:init' listener
         that creates the store and wires the TAB_CHANGED message handler.
         MUST execute before Alpine starts so the listener is already in place
         when Alpine fires 'alpine:init' during its own startup.

      2. alpine.min.js (defer) â€” waits for the DOM to be fully parsed, then
         starts Alpine.  Alpine fires 'alpine:init', our listener runs, the
         store is registered, and Alpine proceeds to walk the DOM.

    Both scripts are local files (no CDN) to comply with Chrome MV3's default
    Content Security Policy, which blocks external script sources.
  -->
  <script src="app.js"></script>
  <script defer src="../lib/alpine.min.js"></script>

  <!-- â”€â”€ Root application wrapper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <!--
    x-data="" is required to activate Alpine.js on this element and all its
    descendants. Without x-data in scope, Alpine ignores every directive in the
    DOM â€” x-show stays inert, @click handlers never fire, :class bindings are
    never evaluated.  An empty x-data creates a component scope that still gives
    full access to $store.app via Alpine's global store mechanism.
  -->
  <div id="app" x-data>

    <!-- â”€â”€ Tab Bar (SPEC.md Â§7.1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <!--
      role="tablist" + role="tab" + aria-selected follows ARIA tabs pattern.
      Active tab is tracked in $store.app.activeTab ("user" | "admin").
      The .tab-btn--active class drives the visual underline indicator in CSS.
    -->
    <nav class="tab-bar" role="tablist" aria-label="Main navigation">
      <button
        role="tab"
        class="tab-btn"
        :class="{ 'tab-btn--active': $store.app.activeTab === 'user' }"
        :aria-selected="$store.app.activeTab === 'user'"
        @click="$store.app.setTab('user')"
      >User</button>
      <button
        role="tab"
        class="tab-btn"
        :class="{ 'tab-btn--active': $store.app.activeTab === 'admin' }"
        :aria-selected="$store.app.activeTab === 'admin'"
        @click="$store.app.setTab('admin')"
      >Admin</button>
    </nav>

    <!-- â”€â”€ User Tab Panel (SPEC.md Â§7.2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <!--
      x-show toggles CSS display instead of removing the element from the DOM.
      This preserves the field-results list when the user briefly switches to
      Admin and returns â€” no re-fetch needed. (design D-5)
    -->
    <!-- No x-cloak: User tab is the default â€” it starts visible, no flash possible -->
    <div id="tab-user" role="tabpanel" aria-label="User" x-show="$store.app.activeTab === 'user'">

      <!-- Page Context Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <!--
        Three mutually exclusive rows, each shown based on pageType.
        Each row carries both an icon and descriptive text â€” never icon-only â€”
        so the state is accessible to screen readers (SPEC.md Â§11 Phase 11 note).
        The coloured dot is aria-hidden because the surrounding text already
        conveys the meaning.
      -->
      <div class="context-banner" role="status" aria-live="polite" aria-atomic="true">

        <div class="context-banner__row context-banner__row--ado"
             x-show="$store.app.pageType === 'ado'">
          <span class="context-dot" aria-hidden="true">ðŸ”µ</span>
          <span>Azure DevOps Initiative detected. Ready to copy.</span>
        </div>

        <div class="context-banner__row context-banner__row--pa"
             x-show="$store.app.pageType === 'pa'">
          <span class="context-dot" aria-hidden="true">ðŸŸ¢</span>
          <span>PowerApps form detected. Ready to paste.</span>
        </div>

        <div class="context-banner__row context-banner__row--unsupported"
             x-show="$store.app.pageType === 'unsupported'">
          <span class="context-dot" aria-hidden="true">âšª</span>
          <span>This page is not supported. Navigate to an ADO Initiative or a PowerApps form.</span>
        </div>

      </div><!-- /context-banner -->

      <!-- Copy / Paste Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <div class="action-buttons">

        <!--
          Copy Initiative button â€” Phase 7 (Â§7.2, design D-6).

          @click calls copyInitiative() which sets copyStatus = "copying",
          sends COPY_INITIATIVE to the service worker, then sets
          copyStatus = "done" with the per-field results.

          :disabled uses isCopyDisabled() â€” a store helper â€” rather than an
          inline expression because the Alpine CSP build prohibits || in
          directive expressions.  (SPEC Â§3.2, design D-6)

          The button is disabled while copying (prevents duplicate requests)
          and when not on an ADO page (nothing to copy from).
        -->
        <button
          class="btn btn--primary"
          @click="$store.app.copyInitiative()"
          :disabled="$store.app.isCopyDisabled()"
        >Copy Initiative</button>

        <!--
          Spinner â€” visible while COPY_INITIATIVE is in flight.
          role="status" + aria-label announces to screen readers that copying
          is in progress.  The spinner disappears as soon as copyStatus
          transitions from "copying" to "done".  (design D-6)
        -->
        <div
          class="spinner"
          x-show="$store.app.copyStatus === 'copying'"
          role="status"
          aria-label="Copying in progressâ€¦"
          x-cloak
        ></div>

        <!-- TODO Phase 10: Paste to PowerApps button + spinner -->
      </div>

      <!-- Field Status List â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <!--
        Per-field results list â€” rendered after a copy operation completes.

        Visibility: shown only when hasCopyResults() returns true â€” a store
        helper that checks `copyStatus === "done" && fieldResults.length > 0`.
        The helper exists because Alpine CSP prohibits && in directives.

        Each row shows the field label and a colour-coded status indicator:
          .status-success â†’ green  (field was read successfully)
          .status-blank   â†’ amber  (field was found but empty in ADO)
          .status-error   â†’ red    (selector failed or unexpected error)

        The :key on the x-for is result.fieldId.  In the error case
        ($success: false), fieldResults contains a single entry with
        fieldId "__error__", which is unique and safe as a key.

        Why x-show on the list rather than x-if?
          x-show keeps the list in the DOM so the results persist when the
          user briefly switches to the Admin tab and back â€” no re-render on
          return.  (design D-5 rationale for x-show)
      -->
      <div class="field-results">
        <ul
          class="field-results-list"
          x-show="$store.app.hasCopyResults()"
          role="list"
          x-cloak
        >
          <template x-for="result in $store.app.fieldResults" :key="result.fieldId">
            <li
              class="field-result"
              :class="{
                'status-success': result.status === 'success',
                'status-blank':   result.status === 'blank',
                'status-error':   result.status === 'error'
              }"
            >
              <!--
                Status dot â€” colour comes from the parent .status-* class.
                aria-hidden because the surrounding label + message text
                already conveys the meaning to screen readers.
              -->
              <span class="field-result__dot" aria-hidden="true"></span>

              <!-- Field label â€” sourced from mapping.label -->
              <span class="field-result__label" x-text="result.label"></span>

              <!--
                Optional message â€” shown for blank and error results.
                x-show="result.message" hides the element when message is
                undefined (success results do not carry a message).
              -->
              <span
                class="field-result__message"
                x-show="result.message"
                x-text="result.message"
              ></span>
            </li>
          </template>
        </ul>

        <!-- TODO Phase 10: render fieldResults after Paste -->
      </div>

    </div><!-- /tab-user -->

    <!-- â”€â”€ Admin Tab Panel (SPEC.md Â§7.3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <!--
      x-cloak prevents the admin panel from briefly flashing visible before
      Alpine initialises and applies x-show. The [x-cloak] CSS rule sets
      display:none immediately at parse time; Alpine removes the attribute
      once it has evaluated the x-show expression.
    -->
    <div id="tab-admin" role="tabpanel" aria-label="Admin" x-show="$store.app.activeTab === 'admin'" x-cloak>

      <!-- â”€â”€ Settings Section (SPEC.md Â§7.3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <!--
        Task 4.1 â€” Overwrite Mode toggle.
        @change passes the checkbox's boolean value to setOverwriteMode()
        rather than assigning directly ($store.app.settings.overwriteMode = x)
        because the Alpine CSP build silently drops assignment expressions in
        directive handlers. Method calls are the correct CSP-safe pattern.
      -->
      <section class="settings-section">
        <h2 class="settings-section__heading">âš™ Settings</h2>
        <label class="overwrite-mode-label">
          <input
            type="checkbox"
            class="overwrite-mode-checkbox"
            :checked="$store.app.getOverwriteMode()"
            @change="$store.app.setOverwriteMode($event.target.checked)"
          />
          Overwrite Mode â€” overwrite existing PA field values during paste
        </label>
      </section>

      <!-- â”€â”€ Field Mappings Section (SPEC.md Â§7.3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <section class="mapping-section">

        <!-- Section header + add button â€” Task 5.1 -->
        <div class="mapping-section__header">
          <span class="mapping-section__title">â”€â”€ Field Mappings â”€â”€</span>
          <button
            class="btn btn--small btn--primary"
            @click="$store.app.openAddForm()"
          >+ Add Mapping</button>
        </div>

        <!-- Empty-state message â€” Task 5.3 -->
        <!--
          Shown when there are no mappings. Uses getMappings() rather than
          settings?.mappings because the CSP expression parser does not support
          optional chaining (?.) or nullish coalescing (??).
        -->
        <p
          class="empty-state"
          x-show="$store.app.getMappings().length === 0"
        >No mappings configured yet. Click + Add Mapping to get started.</p>

        <!-- Mapping list â€” Task 5.2 -->
        <!--
          x-for iterates over settings.mappings.  The :key directive uses
          mapping.id so Alpine can efficiently patch the DOM when a mapping is
          added, removed, or reordered without re-rendering the entire list.
        -->
        <ul class="mapping-list" role="list">
          <template x-for="mapping in $store.app.getMappings()" :key="mapping.id">
            <li class="mapping-row">

              <!-- Label + fieldType badge -->
              <div class="mapping-row__info">
                <span class="mapping-row__label" x-text="mapping.label"></span>
                <!--
                  :class uses object syntax with explicit comparisons â€” template
                  literals are not supported by the CSP expression parser.
                -->
                <span
                  class="badge"
                  :class="{ 'badge--text': mapping.fieldType === 'text', 'badge--lookup': mapping.fieldType === 'lookup', 'badge--choice': mapping.fieldType === 'choice' }"
                  x-text="mapping.fieldType"
                ></span>
              </div>

              <!-- Controls: enabled toggle + edit + delete -->
              <div class="mapping-row__controls">

                <!--
                  Enabled toggle â€” @change fires toggleEnabled() rather than
                  directly mutating mapping.enabled because direct assignment
                  inside event directives is not supported by the CSP build.
                -->
                <label class="mapping-row__enabled-label" title="Enabled">
                  <input
                    type="checkbox"
                    class="mapping-row__enabled-checkbox"
                    :checked="mapping.enabled"
                    @change="$store.app.toggleEnabled(mapping.id)"
                  />
                  <span class="sr-only">Enabled</span>
                </label>

                <button
                  class="btn btn--small btn--secondary"
                  @click="$store.app.openEditForm(mapping.id)"
                >Edit</button>

                <button
                  class="btn btn--small btn--danger"
                  @click="$store.app.deleteMapping(mapping.id)"
                >Delete</button>

              </div><!-- /mapping-row__controls -->
            </li>
          </template>
        </ul><!-- /mapping-list -->

        <!-- â”€â”€ Mapping Form â€” Tasks 6.1â€“6.5 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
        <!--
          x-show toggles the form panel.  The form stays in the DOM (x-show,
          not x-if) so that the adminMappingForm x-data component can register
          its $watch listener in init() even when the form is hidden â€” if we
          used x-if, the component would be destroyed and re-created on every
          open, resetting the $watch binding.

          x-data="adminMappingForm" mounts the local draft state component
          registered via Alpine.data() in app.js. The name is referenced without
          calling parentheses â€” Alpine.data() handles calling the factory function
          internally. Using the registered name (not a bare global function call)
          is required by the CSP build. (design D-1)
        -->
        <div
          class="mapping-form"
          x-show="$store.app.showMappingForm"
          x-data="adminMappingForm"
        >

          <!-- Form heading â€” "Add Mapping" or "Edit Mapping" -->
          <!--
            Uses getFormTitle() store method rather than an inline ternary so
            the expression is a trivial method call â€” no operator ambiguity for
            the CSP parser.
          -->
          <h3
            class="mapping-form__heading"
            x-text="$store.app.getFormTitle()"
          ></h3>

          <!-- Label field -->
          <div class="form-group">
            <label class="form-group__label" for="mapping-label">Label <span aria-hidden="true">*</span></label>
            <input
              id="mapping-label"
              type="text"
              class="form-group__input"
              x-model="label"
              placeholder="e.g. Title"
            />
          </div>

          <!-- ADO Selector field -->
          <div class="form-group">
            <label class="form-group__label" for="mapping-ado-selector">ADO Selector <span aria-hidden="true">*</span></label>
            <input
              id="mapping-ado-selector"
              type="text"
              class="form-group__input"
              x-model="adoSelector"
              placeholder="e.g. input[aria-label='Title']"
            />
          </div>

          <!-- Field Schema Name (PA) field + Phase 8 / 9 deferred buttons -->
          <div class="form-group">
            <label class="form-group__label" for="mapping-field-schema-name">Field Schema Name (PA) <span aria-hidden="true">*</span></label>
            <div class="form-group__row">
              <input
                id="mapping-field-schema-name"
                type="text"
                class="form-group__input"
                x-model="fieldSchemaName"
                placeholder="e.g. cr123_lineofbusiness"
              />
              <!--
                "Pick from Page" (Phase 8) and "Test Field" (Phase 9) buttons
                are present but disabled as non-functional placeholders so the
                layout slot is reserved and the buttons are discoverable in the
                UI. They will be wired in later phases. (design Non-Goals)
              -->
              <button class="btn btn--small btn--secondary" disabled title="Available in Phase 8">Pick from Page</button>
              <button class="btn btn--small btn--secondary" disabled title="Available in Phase 9">Test Field</button>
            </div>
          </div>

          <!-- Field Type select -->
          <div class="form-group">
            <label class="form-group__label" for="mapping-field-type">Field Type <span aria-hidden="true">*</span></label>
            <select
              id="mapping-field-type"
              class="form-group__select"
              x-model="fieldType"
            >
              <option value="text">text</option>
              <option value="lookup">lookup</option>
              <option value="choice">choice</option>
            </select>
          </div>

          <!-- Inline validation error â€” Task 6.4 -->
          <!--
            x-show hides the element when formError is empty (falsy).
            x-text populates the message without innerHTML injection risk.
          -->
          <p class="inline-error" x-show="formError" x-text="formError"></p>

          <!-- Save + Cancel buttons â€” Task 6.5 -->
          <div class="mapping-form__actions">
            <button class="btn btn--primary" @click="save()">Save</button>
            <button class="btn btn--secondary" @click="$store.app.closeForm()">Cancel</button>
          </div>

        </div><!-- /mapping-form -->

      </section><!-- /mapping-section -->

      <!-- â”€â”€ Export / Import (Phase 6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <!--
        Export â€” clicking serialises the in-memory settings to Â§4.4 JSON and
        triggers a browser download of ado-pa-mappings.json. No page-type guard
        needed â€” export works regardless of the active page. (Â§7.3)

        Import â€” clicking programmatically triggers the hidden file input.
        The file picker fires a `change` event which drives the full import
        flow in $store.app.importMappings. (design.md Decision 3)

        Hidden file input â€” uses class="visually-hidden" (not display:none)
        so programmatic .click() is reliably honoured across browsers.
        x-ref="importFileInput" lets the Import button reach it via $refs
        without a DOM getElementById call. (Â§7.3)

        importMessage feedback â€” shown below the buttons after each import
        attempt. Green for success, red for errors. Cleared at the start of
        the next attempt, not on a timer. (design.md Decision 5)
      -->
      <section class="import-export-section">
        <div class="import-export-bar">
          <button
            class="btn btn--secondary"
            @click="$store.app.exportMappings()"
          >â†“ Export Mappings</button>

          <button
            class="btn btn--secondary"
            @click="$refs.importFileInput.click()"
          >â†‘ Import Mappings</button>

          <!--
            Hidden file input â€” must NOT use display:none because some browsers
            do not fire click() on hidden elements. .visually-hidden positions
            it off-screen (still in layout) so .click() works reliably.
            accept=".json" filters the picker to JSON files for clarity,
            though the import flow validates the content regardless.
          -->
          <input
            type="file"
            accept=".json"
            x-ref="importFileInput"
            class="visually-hidden"
            @change="$store.app.importMappings($event)"
          />
        </div>

        <!--
          Inline import result message.
          x-show hides the element when importMessage is null (falsy).
          :class adds the success or error style modifier.
          x-text sets the message text safely (no innerHTML injection risk).

          Why store helper methods rather than inline expressions?
            The Alpine CSP expression parser does not support && (logical AND),
            optional chaining, or nullish coalescing. Wrapping the null-checks
            in isImportSuccess(), isImportError(), and getImportMessageText()
            keeps the directives as trivial method calls that the CSP parser
            handles without issue. (design.md Decision 1)
        -->
        <p
          class="import-message"
          x-show="$store.app.importMessage"
          :class="{ 'import-message--success': $store.app.isImportSuccess(), 'import-message--error': $store.app.isImportError() }"
          x-text="$store.app.getImportMessageText()"
        ></p>
      </section>

    </div><!-- /tab-admin -->

  </div><!-- /app -->

</body>
</html>
